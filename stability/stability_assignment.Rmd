---
title: "Stability Assignment"
author: "Mia Guarnieri, Lauren Harris"
date: "2023-06-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Packages
```{r}
library(here)
library(tidyverse)
library(deSolve)
```

Source function
```{r}
source(here("stability", "lotvmodK.R"))
```

Definition of stability: a population that has a positive or 0 derivative (growth) and has a population size above or equal to the initial population size after 10 years

Test the function
```{r}
# given some characteristics - lets look at derivatives under different harvest rates
pars = list(rprey=0.95, alpha=0.01, eff=0.6,pmort=0.4, K=2000, harvest = 20)
pop = list(prey = 100, pred = 10)
# look at the derivative over a range of harvest thresholds
findstable = data.frame(thresh=seq(from=10, to=150, by=1))

# notice use of Time=NULL, and map to compute derivative
# for different values of forest biomass
findstable$dprey = unlist(findstable$thresh %>% map(~lotvmodK(pars=pars, t=NULL, pop=pop, thresh = .x)))[[1]]

findstable$dpred = unlist(findstable$thresh %>% map(~lotvmodK(pars=pars, t=NULL, pop=pop, thresh = .x)))[[2]]

# test out min and max in function
lotvmodK(pars=pars, t=NULL, pop=pop, thresh = min(findstable))
lotvmodK(pars=pars, t=NULL, pop=pop, thresh = max(findstable))
```

```{r}
findstable = data.frame(harvest=seq(from=0, to=100, by=5))

```

Test the function over time (varied harvest)

```{r}
# set parameter list
# given some characteristics - lets look at derivatives under different harvest rates
pars = list(rprey=0.95, alpha=0.01, eff=0.6,pmort=0.4, K=2000, harvest = 20)

# now lets try initial conditions that will be stable
predi = with(pars, pmort/(eff*alpha)) 

preyi = with(pars, rprey/alpha*(1-preyi/K)) 

pop = c(prey = as.integer(preyi), pred = as.integer(predi))

# times when you want to evaluate
days = seq(from=1, to=100)

# look at the derivative over a range of harvest thresholds
thresh_df<- data.frame(thresh = seq(from=10, to=150, by=1))

# run our differential equation solver
results <- thresh_df$thresh %>% 
                map(~ode(func=lotvmodK, y = pop, times=days, parms=pars, thresh = .x))

restest <- ode(func=lotvmodK, y = pop, times=days, parms=pars, thresh = 50)

final_pop <- as.data.frame(unlist(sapply(results, \(x) tail(x[x != ""], 1))))

final_pop <- sapply(results, tail, 1)

# extract the results
res_stablestart = as.data.frame(res) %>% 
  gather(key="animal", value="pop",-time)


# graph both populations over time
p1=ggplot(res_smallstart, aes(time, pop, col=animal))+geom_line()
p1

# lets first see what happens when we start our estimates of stable populations
stablepop = c(prey=preyi, pred=predi)
res = ode(func=lotvmodK, y=stablepop, times=days, parms=pars)
# estract the results
res_stablestart = as.data.frame(res) %>% gather(key="animal", value="pop",-time)
# graph both populations over time
p2=ggplot(res_stablestart, aes(time, pop, col=animal))+geom_line()
p2



#use a wrapper function with pmap

#threshold and harvest lists
thresh_l <- seq(from = 10, to = 150, by = 1)
harvest_l <- seq(from = 0.05, to = 0.25, by = 0.01)

# times when you want to evaluate
times <- seq(from=1, to=200)


h_wrapper <- function(t, func, pop, rprey, alpha, eff, pmort, K, harvest, thresh) {
    pars <- list(rprey=rprey, alpha=alpha, eff=eff, pmort=pmort, K=K, harvest = harvest, thresh = thresh)
    
    #run the ode solver
    result <- ode(y = pop, times = times, func = func, parms = pars) 
  
    #turn into dataframe and get max value
    result <- as.data.frame(result)
    colnames(result) = c("time", "prey", "pred")
    final_pop <- tail(result, n = 1)
    
    return(final_pop)
}

#use pmap to apply wrapper to all parameter sets

times <- 1:200

pars_l <- list(rprey=0.95, alpha=0.01, eff=0.6,pmort=0.4, K=2000, harvest = 0.10, thresh = thresh_l)

pars_df <- as.data.frame(pars_l)

#setting initial population values
predi <- with(pars_l, pmort/(eff*alpha))
preyi <- with(pars_l, rprey/alpha*(1-predi/K))
pop <- c(prey = as.integer(preyi), pred = as.integer(predi))

all_results <- pars_df %>% 
  pmap(h_wrapper, t = times, func = lotvmodK, pop = pop)

```